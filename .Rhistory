if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
install.packages("RSQLite")
library(BiocManager)
install.packages("DT")
library(DT)
#word cloud
install.packages("tm")
install.packages("SnowballC")
install.packages("wordcloud")
install.packages("RColorBrewer")
library(tm)
library(SnowballC)
library(wordcloud)
library(RColorBrewer)
# load data
autcon <- readRDS('autism_control.RDS')
str(autcon)
# run ROSETTA
library(rJava)
library(R.ROSETTA)
ros <- rosetta(autcon)
# quality:
qual <- ros$quality
qual
# how many rules obtained:
dim(viewRules(ros$main))[1]
# visualize wit VisuNet
vis <- visunet(ros$main)
str(vis)
vis$control
# find overlapping genes
SFARI <- readRDS('SFARI_Genes.RDS')
overlapped_genes <- SFARI[which(SFARI$gene.symbol %in% vis$all$nodes$label),]
most_signif_gene <- overlapped_genes$gene.name[which.max(overlapped_genes$gene.score)]
most_signif_gene
BiocManager::install("DO.db")
BiocManager::install("GO.db")
BiocManager::install("clusterProfiler", force = T)
library(clusterProfiler)
#if (!requireNamespace("BiocManager", quietly = TRUE))
# install.packages("BiocManager")
BiocManager::install("org.Hs.eg.db", force = T)
library(org.Hs.eg.db)
gene_entrez <- bitr(unique(as.character( vis$all$nodes$label)), fromType = 'SYMBOL',
toType = c("ENTREZID") , org.Hs.eg.db)
genes_GO <- groupGO(gene = unique(gene_entrez$ENTREZID),
OrgDb = org.Hs.eg.db,
ont = "MF",
level = 5,
readable = TRUE)
genes_GO@result[which.max(genes_GO@result$Count),]
x1 <- genes_GO@result[which(genes_GO@result$Count>2),c('ID', 'Count')]
x <- as.numeric(x1[,2])
names(x)<- x1$ID
barplot(x, col = rainbow(20), las=2 )
'
Interpretation: ...
'
names(x)
#genes associated with the top term
genes_top_GO<-strsplit(genes_GO@result[which.max(genes_GO@result[, 'Count' ]),'geneID'],'/')[[1]]
#create a new variable that contains node information for the "all" decision
nodes_RNO <- vis$all$nodes
#create a new vector of variables: shape. "dot" is the default shape of nodes
nodes_RNO$shape <- rep("dot", length(nodes_RNO$label))
#mark selected genes as stars using the label attribute
nodes_RNO$shape[which(as.character(nodes_RNO$label) %in% genes_top_GO)] <- "star"
#create the node object list
nodesL <- list(nodes = nodes_RNO,CustCol = c("shape"))
#rerun VisuNet with the new shape for nodes
vis_out2 <- visunet(ros$main, CustObjectNodes = nodesL)
#rerun VisuNet with the new shape for nodes
vis_out2 <- visunet(ros$main, CustObjectNodes = nodesL)
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(rJava)
# install and load necessary packages
install.packages("rJava")
library(rJava)
library(rmcfs)
install.packages("rmcfs")
library(rJava)
library(rmcfs)
install.packages(yaml)
install.packages("yaml")
library(rmcfs)
library(R.ROSETTA)
library(devtools)
install.packages("devtools")
library(devtools)
install.packages("devtools")
warnings()
install.packages("BiocManager")
install.packages("devtools")
# analyze the rule-based model
gf <- getFeatures(rules, filter = T, filterType = "pvalue", thr = 0.05)
#install.packages("devtools")
#library(devtools)
#install_github("komorowskilab/R.ROSETTA")
library(R.ROSETTA)
# run rosetta with autcon data
autconJohnson <- rosetta(autcon, roc = TRUE, clroc = "autism")
rules <- autconJohnson$main
qual <- autconJohnson$quality
# print top 12 rules
rlsAut <- viewRules(rules[rules$decision=="autism",], setLabels=TRUE, labels=c("low", "medium", "high"))
print(rlsAut[1:12,])
# significant rules in the model
tabS <- table(rules[rules$pValue < 0.05,]$decision)
# ROC curve
plotMeanROC(autconJohnson)
# analyze the rule-based model
gf <- getFeatures(rules, filter = T, filterType = "pvalue", thr = 0.05)
genesAutism <- gf$features$autism
genesControl <- gf$features$control
# display common genes for both classes
intersect(genesAutism, genesControl)
setdiff(genesAutism, genesControl)
setdiff(genesControl, genesAutism)
# recalculate the model
recAutconJohnson <- recalculateRules(autcon, rules)
# find most significant rule for Autism
idx <- which.min(recAutconJohnson[recAutconJohnson$decision=="autism",]$pValue)
topRuleInd <- which((recAutconJohnson$decision=="autism")==TRUE)[idx]
topRuleInd
# set new labels for plots using parameter label=c()
plotRule(autcon, recAutconJohnson, type="heatmap", discrete=FALSE, ind=topRuleInd, label = c(3,2,1))
typeof(autcon)
typeof(recAutconJohnson)
# set new labels for plots using parameter label=c()
plotRule(autcon, recAutconJohnson, type="heatmap", discrete=FALSE, ind=1, label = c(3,2,1))
plotRule(autcon, recAutconJohnson, type="boxplot", discrete=FALSE, ind=1)
# set new labels for plots using parameter label=c()
plotRule(autcon, recAutconJohnson, type="heatmap", discrete=FALSE, ind=12, label = c(3,2,1))
plotRule(autcon, recAutconJohnson, type="boxplot", discrete=FALSE, ind=12)
# set new labels for plots using parameter label=c()
plotRule(autcon, recAutconJohnson, type="heatmap", discrete=FALSE, ind=22, label = c(3,2,1))
# set new labels for plots using parameter label=c()
plotRule(autcon, recAutconJohnson, type="heatmap", discrete=FALSE, ind=32, label = c(3,2,1))
# set new labels for plots using parameter label=c()
plotRule(autcon, recAutconJohnson, type="heatmap", discrete=FALSE, ind=3, label = c(3,2,1))
# set new labels for plots using parameter label=c()
plotRule(autcon, recAutconJohnson, type="heatmap", discrete=FALSE, ind=4, label = c(3,2,1))
recAutconJohnson[recAutconJohnson$decision == "autism",]
recAutconJohnson[recAutconJohnson$decision == "autism",][12]
recAutconJohnson[recAutconJohnson$decision == "autism",][13]
recAutconJohnson[recAutconJohnson$decision == "autism",12]
recAutconJohnson[recAutconJohnson$decision == "autism",13]
recAutconJohnson[recAutconJohnson$decision == "autism",1]
plotRule(autcon, recAutconJohnson, type="boxplot", discrete=FALSE, ind=11)
head(recAutconJohnson)
recAutconJohnson[12]
x = c(-10:10)
x
x1 = c(-10:10)
x2 = c(-20:2:20)
x2
x2 = c(-20:20:2)
x2
x2 = x1*2
x2
df = data.frame(y, x1, x2)
y = c(0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,0,1,0,0])
y = c(0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,0,1,0,0)
df = data.frame(y, x1, x2)
y = c(0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,1,0,1,0,0,1)
df = data.frame(y, x1, x2)
df
log?model <- glm(y ~ x1 + x2. data = df)
log_model <- glm(y ~ x1 + x2. data = df)
log_model <- glm(y ~ x1 + x2, data = df)
log_model
y = c(0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1)
df = data.frame(y, x1, x2)
log_model <- glm(y ~ x1 + x2, data = df)
log_model
x2 = c(0:20)
df = data.frame(y, x1, x2)
log_model <- glm(y ~ x1 + x2, data = df)
log_model
log_model <- glm(y ~ x1, data = df)
log_model
?glm
log_model <- glm(y ~ x1, data = df, family = 'binomial')
log_model
summary(log_model)
log_model <- glm(y ~ x1 + x2, data = df, family = 'binomial')
summary(log_model)
mtcars
names(mtcars)
log_model2 <- glm(vs ~ wt + disp, family = 'binomial')
log_model2 <- glm(vs ~ wt + disp, data=mtcars, family = 'binomial')
summary(log_model2)
mtcars
summary(log_model2)
?glm.git
?glm.fit
log_model2 <- glm.fit(vs ~ wt + disp, data=mtcars, family = 'binomial', )
load(mtcars)
log_model2 <- glm.fit(c(mtcars$wt, mtcars$disp), mtcars$vs, family = 'binomial', )
log_model2 <- glm.fit(c(mtcars$wt, mtcars$disp), mtcars$vs, family = 'binomial')
log_model2 <- glm.fit(vs ~ wt + disp, data=mtcars, family = 'binomial', )
log_model2 <- glm(vs ~ wt + disp, data=mtcars, family = 'binomial', )
summary(log_model2)
?glm
?L-BFGS
library(L-BFGS)
install.packages("L-BFGS")
log_model2 <- glm(vs ~ wt + disp, data=mtcars, family = 'binomial', method = 'bfgs')
install.packages("lbfgs")
?lbfgs
library(lbfgs)
lbfgs
?lbfgs
Sci = c(70,71,72,73,68,69,65,69,80,68)
Mat = c(91,92,93,94,65,69,61,55,91,79)
Eng = c(82,83,84,85,73,66,50,62,95,68)
Pass = c(1,1,1,1,0,0,0,0,1,0)
df=data.frame(Sci,Mat,Eng,Pass)
install.packages("neuralnet")
library("neuralnet")
warnings()
nn=neuralnet(Pass~Sci+Mat+Eng,data=df, hidden=3,act.fct = "logistic",
linear.output = FALSE)
plot(nn)
test=data.frame(sci,mat,eng)
sci = c(80,75,65,68)
mat = c(95,92,69,45)
eng = c(85,83,55,50)
test=data.frame(sci,mat,eng)
predict=compute(nn,test)
predict$net.result
probab<- predict$net.result
pre <- ifelse(probab>0.5, 1, 0)
pre
Sci = c('A','A','B','C','D','E','F','B','C','B')
Mat = c(91,92,93,94,65,69,61,55,91,79)
Eng = c(82,83,84,85,73,66,50,62,95,68)
Pass = c(1,1,1,1,0,0,0,0,1,0)
df=data.frame(Sci,Mat,Eng,Pass)
nn=neuralnet(Pass~Sci+Mat+Eng,data=df, hidden=3,act.fct = "logistic",
linear.output = FALSE)
?neuralnet
update(RStudio)
RStudio.Version()
update()
version
RStudio.Version()
# in this assignment use a 'cluster' package
# install and load library
install.packages("cluster") # if successful, do it only once
warnings()
library(cluster)
### TASK 1 - check and prepare the data ###
# the data exist in the workspace
print(iris)
# show features
colnames(iris)
# check the number of species
specs <- iris$Species # select last column
specsLevs <- levels(specs) # select levels of variables (levels works only with Factor)
specsNum <- length(specsLevs) # how many = length
# how many flowers per species?
table(iris$Species)
# try summary function
summary(iris)
# structure of the object iris$Species
str(iris$Species)
# choose two features for the analysis e.g.
f1 <- "Sepal.Length"
f2 <- "Petal.Length"
features <- c(f1, f2)
selectedIris <- iris[,features] # or just iris[features]
### TASK 2 - perform k-means clustering ###
fitKmeans <- kmeans(selectedIris, specsNum, iter.max = 100)
# plot the result of k-means clustering
# Fig.1
clusplot(selectedIris, fitKmeans$cluster, color=TRUE, shade=TRUE,
labels=0, lines=0, main = "k-means clustering")
### TASK 3 - perform hierarchical clustering ###
d <- dist(selectedIris) # estimate distance
fitHier <- hclust(d, method = "ward.D")
clusterCut <- cutree(fitHier, specsNum)
# Fig.2a
clusplot(selectedIris, clusterCut, color=TRUE, shade=TRUE,
labels=0, lines=0, main = "hierarchical clustering")
# Fig.2b
dend <- as.dendrogram(fitHier)
nodeParams <- list(pch = c(NA, 18), cex = 0.5, col = "darkgray")
plot(dend, type = "rectangle", nodePar = nodeParams, leaflab = "none", main = "hierarchical clustering")
rect.hclust(fitHier, k = 3, border = "darkorange")
# calculate centroids for the hierarchical clustering
# here, we are using aggregate function, read more about how it works using ?aggregate
hierCentr <- aggregate(data.frame(clusterCut, selectedIris), by = list(clusterCut), FUN = mean)
# display both clustering methods on single plot
opar2 <- par(mfrow = c(1,2)) # (Figure.3)
# k-means
plot(selectedIris, type = "n", main = "k-means clustering")
text(selectedIris, labels = iris$Species, col = c("orangered", "limegreen", "dodgerblue")[fitKmeans$cluster])
points(fitKmeans$centers[, features], col = "yellow", pch = 15, cex = 1.5)
# hierarchical
plot(selectedIris, type = "n", main = "hierarchical clustering")
text(selectedIris, labels = iris$Species, col = c("darkviolet", "darkorange", "seagreen4")[clusterCut])
points(hierCentr[, features], col = "yellow", pch = 15, cex = 1.5)
par(opar2)
library(VisuNet)
?visunet
R.home()
warnigns()
warnings()
R.home()
R.version
print(R.home())
chooseCRANmirror()
install.packages("stats")
install.packages("stats")
install.packages("stats")
warnings()
writeLines('PATH="C:\rtools42\usr\bin;${PATH}"', con = "~/.Renviron")
writeLines(PATH="C:\rtools42\usr\bin;${PATH}", con = "~/.Renviron")
Sys.which("make")
.libPaths()
warnings()
?install.packages
options()
library(rmcfs)
installed.packages()[,c(1,3,4)]
library(rJava)
library(rmcfs)
library(dplyr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# load data set
alizadeh <- read.table("alizadeh.csv")
# display first n lines of data set
n = 10
alizadeh[1:n, c(1:n, dim(alizadeh)[2])]
# reveal structure of data set
decision_attribute = names(alizadeh[dim(alizadeh)[2]])
attributes = names(select(alizadeh, -decision_attribute))
attributes = names(select(all_of(alizadeh, -decision_attribute)))
universe = dim(alizadeh)[1]
# check alizadeh$class ...
alizadeh$class
table(alizadeh$class)
# load data set
alizadeh <- read.table("alizadeh.csv")
result <- mcfs(class~., alizadeh, projections=1500, projectionSize=0.1,
splits=5, cutoffPermutations = 3)
View(alizadeh)
View(alizadeh)
View(alizadeh)
print(result)
head(result$RI)
plot(result, type = "distances")
result$cutoff_value
result[1:result$cutoff_value,]
result[12]
result$RI[12]
result$RI[12,]
x = 1
rm(list = ls()) # deletes your environment (variables, data, etc)
# The following command sets your working directory to the path where the file is saved
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
set.seed(0)
library(R.ROSETTA)
# load data
load_data <- function(file_name, header=T, sep=',', colClass="character", decisionNumeric=T) {
dat = read.csv(file_name, header = header, sep = sep, colClasses = colClass)
if(decisionNumeric){
dat[,dim(dat)[2]] = as.numeric(dat[,dim(dat)[2]])
}
return(dat)
}
dat <- load_data("NS1.csv")
# output from Uppmax
umax = readRDS("df_for_rosetta")
umax = umax[,names(umax)!="id"]
names(umax)
which(umax == names(umax))
umax
which(dat == names(umax))
names(dat)
names(umax)
names(umax)[1]
which(dat = names(umax)[1])
which(dat == names(umax)[1])
which(names(dat) == names(umax)[1])
dat[,90]
x = c()
for (i in names(umax)) {
x = append(x, which(names(dat) == i))
}
x
names(umax)
s = "["
for (i in x){
s = paste0(s, paste0(i, ", "))
}
s = paste0(s, "]")
s
length(names(umax))
ros = run_Rosetta(umax, underSampleNum = 10)
run_Rosetta <- function(df, roc = T, clroc = 1, discrete = T, undersample = T, underSampleNum = 0, method = "Johnson"){
ros <- rosetta(df, roc = roc, clroc = clroc, discrete = discrete, underSample = undersample, underSampleNum = underSampleNum, reducer = method)
return(ros)
}
ros = run_Rosetta(umax, underSampleNum = 10)
ros$quality
umax
umax[1:10,]
umax[,1:10]
cbind(umax[,1:10], umax[,101])
#ros = run_Rosetta(umax, underSampleNum = 10)
ros = run_Rosetta(cbind(umax[,1:10], umax[,101]), underSampleNum = 10)
cbind(umax[,1:10], umax[,101])cbind(umax[,1:10], umax[,101])
cbind(umax[,1:10], umax[,101])
#ros = run_Rosetta(umax, underSampleNum = 10)
x = cbind(umax[,1:10], umax[,101])
ros = run_Rosetta(x, underSampleNum = 10)
ros = run_Rosetta(x)
#ros = run_Rosetta(umax, underSampleNum = 10)
x = cbind(umax[,1:100], umax[,101])
ros = run_Rosetta(x)
ros = run_Rosetta(umax, underSampleNum = 10)
ros$main
ros$quality
x
str(x)
is.data.frame(x)
is.data.frame(umax)
dim(x)
dim(umax)
x == umax
which((x == umax) == FALSE)
x = cbind(umax[,1:100], umax[,101])
rosx = run_Rosetta(x, underSampleNum = 10)
x
dim(x)
name(x$`umax[, 101])
)
)
names(x$`umax[, 101])
names(x)
names(x)[101]
names(x)[101] = "Pathogenicity"
names(x)[101]
x
rosx = run_Rosetta(x, underSampleNum = 10)
x = cbind(umax[,1:100], umax[,101])
rosx = run_Rosetta(x, underSampleNum = 10)
x = cbind(umax[,1:100], umax[,101])
names(x)[101] = "Pathogenicity"
rosx = run_Rosetta(x, underSampleNum = 10)
x = cbind(umax[,1:10], umax[,101])
names(x)[101] = "Pathogenicity"
names(x)[11] = "Pathogenicity"
length(x)
names(x)[length(x)] = "Pathogenicity"
x
rosx = run_Rosetta(x, underSampleNum = 10)
rosx$quality
viewRules(rosx$main)
x = cbind(umax[,1:6], umax[,101])
names(x)[length(x)] = "Pathogenicity"
rosx = run_Rosetta(x, underSampleNum = 10)
rosx$quality
viewRules(rosx$main)
x = cbind(umax[,1:5], umax[,101])
names(x)[length(x)] = "Pathogenicity"
rosx = run_Rosetta(x, underSampleNum = 10)
rosx$quality
viewRules(rosx$main)
x = cbind(umax[,1:2], umax[,101])
names(x)[length(x)] = "Pathogenicity"
rosx = run_Rosetta(x, underSampleNum = 10)
rosx$quality
viewRules(rosx$main)
x = cbind(umax[,1:1], umax[,101])
names(x)[length(x)] = "Pathogenicity"
rosx = run_Rosetta(x, underSampleNum = 10)
x
x = cbind(umax[,1], umax[,101])
names(x)[length(x)] = "Pathogenicity"
x
names(x)
x = cbind(umax[,1], umax[,101])
x
x = data.frame(cbind(umax[,1], umax[,101]))
names(x)[length(x)] = "Pathogenicity"
x
rosx = run_Rosetta(x, underSampleNum = 10)
rosx$quality
viewRules(rosx$main)
viewRules(rosx$main)
rosx$ROC.stats
plot(rosx$ROC.stats)
?R.ROSETTA
plotMeanROC(rosx$ROC.stats)
plotMeanROC(rosx$quality)
plotMeanROC(rosx)
x = data.frame(cbind(umax[,1:10], umax[,101]))
names(x)[length(x)] = "Pathogenicity"
rosx = run_Rosetta(x, underSampleNum = 10)
plotMeanROC(rosx)
x = data.frame(cbind(umax[,1:100], umax[,101]))
names(x)[length(x)] = "Pathogenicity"
rosx = run_Rosetta(x, underSampleNum = 10)
plotMeanROC(rosx)
